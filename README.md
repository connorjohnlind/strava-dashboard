Client-side Notes:

- the string-based data structure of the strava API made a huge impact on the way data was passed to the totals component...having to find maximums by searching through 'recent_ride_totals' instead of working with objects was a bit of a pain...i decided to leave the api data 'as is' in redux (from the API), and build more convenient objects in react containers (i.e. getMaximums in Totals), to pass the proper formatted data in as props to Charts...if the strava totals API endpoint would have been needed in other componenets, I might have decided to manipulate the data to a more desirable format straight away in the action creator and build objects based on range (such as recent.ride.totals.count instead of dealing with template strings in recent_ride_totals.count)

- utilizing a config file for the sports, ranges, and their labels made for a lot more DRY iteration throughout the app that might be overkill (considering that it's very unlikely that running, biking, swimming will ever change in the context of a triathlete-focused app)...however I found it to be useful exercise to allow all of my app components to adjust to this configuration (renaming month to 4 weeks for example)...there are just a few instances where I opted to hard code based on sport...such as the color coding of run/ride/swim in CSS files

- the app started with a mobile-first design but desktop quickly became the focus. a best attempt was made retreo-actively to make mobile sufficient, but as a developer I'm becomming increasingly biased towards making separate mobile/desktop apps than building an all-in-one solution

Back-end notes:

- It became clear almost immediately that building a portfolio project targeted towards power users of a specific app isn't a good demonstration for the general public...I therefore decided to save my strava data to a mongodb instance and serve that from /demo. There were a few other approaches that were possible, i.e. calling the strava api with my authentication on Node, and serving that to /demo directly...but if any access tokens were revoked or expired the app would break. Therefore serving some static assets from Mongo seemed the best approach. You can view the script file here, where I use Node's native Mongo driver to serve a local JS object (copy and pasted from my 'auth' reducer in redux dev tools). The data, properly formatted for the client side, is then added to a 'demo' reducer in the app upon GET /demo.
